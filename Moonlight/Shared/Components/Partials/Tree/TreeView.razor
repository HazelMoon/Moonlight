@using Moonlight.App.Models.Abstractions

<div>
    @for (int y = 0; y < DeepY; y++)
    {
        bool nameInThisLine = false;

        <div class="d-flex flex-row">
            @for (int x = 0; x < DeepX; x++)
            {
                if (Grid[x, y] != null)
                {
                    var gridItem = Grid[x, y]!;

                    switch (gridItem.Type)
                    {
                        case 1:
                            if (!string.IsNullOrEmpty(gridItem.Element!.Icon))
                            {
                                <div class="ps-1 py-2">
                                    <i class="@(gridItem.Element!.Icon)"></i>
                                </div>
                            }

                            <div class="ps-3 py-2 fs-5">
                                <span>@(gridItem.Element!.Name)</span>
                            </div>

                            nameInThisLine = true;
                            break;
                        case 2:
                            <div class="ps-1 py-2">
                                @if (gridItem.Element!.IsExpanded)
                                {
                                    <a href="#" @onclick:preventDefault @onclick="() => ToggleExpanded(gridItem)">
                                        <i class="bx bx-sm bxs-minus-square text-white"></i>
                                    </a>
                                }
                                else
                                {
                                    <a href="#" @onclick:preventDefault @onclick="() => ToggleExpanded(gridItem)">
                                        <i class="bx bx-sm bxs-plus-square text-white"></i>
                                    </a>
                                }
                            </div>
                            break;
                        case 3:
                            <div class="ms-1 py-2 ps-5 pe-1" style="background-image: url('svg/lineSide.svg'); background-repeat: no-repeat; background-size: cover; background-position: center"></div>
                            break;
                        case 4:
                            <div class="ms-1 py-2 ps-5 pe-1" style="background-image: url('svg/side.svg'); background-repeat: no-repeat; background-size: cover; background-position: center"></div>
                            break;
                        case 5:
                            <div class="ms-1 py-2 ps-5 pe-1" style="background-image: url('svg/line.svg'); background-repeat: no-repeat; background-size: cover; background-position: center"></div>
                            break;
                    }
                }
                else
                {
                    if (!nameInThisLine)
                    {
                        <div class="ms-1 py-2 ps-5 pe-1"></div>
                    }
                }
            }
        </div>
    }
</div>

@code
{
    [Parameter] public TreeElement RootElement { get; set; }

    private TreeElementViewData?[,] Grid { get; set; } // x|y
    private int DeepX;
    private int DeepY;

    protected override void OnInitialized()
    {
        CalculateGrid();
    }

    private void CalculateGrid()
    {
        DeepY = GetYLength(RootElement);
        DeepX = GetXLength(RootElement);
        
        Grid = new TreeElementViewData[DeepX, DeepY];

        AddElementToGrid(RootElement, null, 0, 0);
    }

    private int GetYLength(TreeElement treeElement)
    {
        if (treeElement.IsExpanded && treeElement.Elements.Any())
        {
            int l = 1;

            foreach (var element in treeElement.Elements)
            {
                l += GetYLength(element);
            }

            return l;
        }
        else
            return 1;
    }

    private int GetXLength(TreeElement treeElement)
    {
        if (treeElement.IsExpanded && treeElement.Elements.Any())
        {
            int l = 0;

            foreach (var element in treeElement.Elements)
            {
                var elementX = GetXLength(element);

                if (elementX > l)
                    l = elementX;
            }

            return l + 3;
        }
        else
            return 3;
    }

    private void AddElementToGrid(TreeElement treeElement, TreeElement? rootElement, int posX, int posY)
    {
        if (rootElement == null)
        {
            if (treeElement.Elements.Any())
            {
                Grid[0, 0] = new TreeElementViewData()
                {
                    Element = treeElement,
                    Type = 2
                };

                Grid[1, 0] = new TreeElementViewData()
                {
                    Element = treeElement,
                    Type = 1
                };
            }
            else
            {
                Grid[0, 0] = new TreeElementViewData()
                {
                    Element = treeElement,
                    Type = 1
                };
            }
        }
        else
        {
            if (treeElement.Elements.Any())
            {
                Grid[posX, posY] = new TreeElementViewData()
                {
                    Element = treeElement,
                    Type = 2
                };

                Grid[posX + 1, posY] = new TreeElementViewData()
                {
                    Element = treeElement,
                    Type = 1
                };
            }
            else
            {
                Grid[posX, posY] = new TreeElementViewData()
                {
                    Element = treeElement,
                    Type = 1
                };
            }
        }

        if (treeElement.IsExpanded)
        {
            int ii = 1;
            int lineOffset = 0;

            foreach (var element in treeElement.Elements)
            {
                var lineYPos = posY + ii + lineOffset;

                Grid[posX, lineYPos] = new TreeElementViewData()
                {
                    Type = (ii == treeElement.Elements.Count ? 4 : 3)
                };

                if (ii != treeElement.Elements.Count)
                {
                    var elementLength = (element.IsExpanded ? GetYLength(element) - 1 : 0);

                    for (int iii = 1; iii <= elementLength; iii++)
                    {
                        Grid[posX, lineYPos + iii] = new TreeElementViewData()
                        {
                            Type = 5
                        };
                    }

                    lineOffset = elementLength;
                }

                ii++;
            }

            TreeElement? previousElement = null;

            int i = 1;
            foreach (var element in treeElement.Elements)
            {
                var topOffset = 0;

                if (previousElement != null)
                    topOffset = GetYLength(previousElement) - 1;

                AddElementToGrid(element, treeElement, posX + 1, posY + i + topOffset);

                previousElement = element;

                i++;
            }
        }
    }

    private async Task ToggleExpanded(TreeElementViewData gridItem)
    {
        gridItem.Element!.IsExpanded = !gridItem.Element!.IsExpanded;
        CalculateGrid();

        await InvokeAsync(StateHasChanged);
    }
}